import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
import MOT_sims.constants as constants
import glob
import pickle

all_results = []

# If you only have one file, just change this to: glob.glob("mot_simulation_data.pkl")
for file_path in glob.glob("mot_simulation_data.pkl"):
    with open(file_path, 'rb') as f:
        node_results = pickle.load(f)
        all_results.extend(node_results) 

print(f"Successfully loaded data for {len(all_results)} atoms!")

# 1. Setup Data
unit_to_mm = (1 / constants.kmag_real) * 1000
num_atoms = len(all_results)
# We use fewer frames so the GIF isn't 500MB
# Let's take 100 snapshots over the course of the simulation
num_frames = 100 
t_indices = np.linspace(0, 5000, num_frames, dtype=int) # Adjust 5000 to your t_eval length

fig = plt.figure(figsize=(8, 8))
ax = fig.add_subplot(111, projection='3d')

# This initialized the "dots" we will move in the animation
scat = ax.scatter([], [], [], s=10, color='royalblue', alpha=0.7)

# Set static limits so the "camera" doesn't shake
ax.set_xlim(-2, 2) # mm
ax.set_ylim(-2, 2)
ax.set_zlim(-2, 2)
ax.set_xlabel('X (mm)')
ax.set_ylabel('Y (mm)')
ax.set_zlabel('Z (mm)')

def update(frame):
    ti = t_indices[frame]
    x, y, z = [], [], []
    
    for atom in all_results:
        _, r, _ = atom
        x.append(r[0, ti] * unit_to_mm)
        y.append(r[1, ti] * unit_to_mm)
        z.append(r[2, ti] * unit_to_mm)
    
    # Update the positions of the dots
    scat._offsets3d = (x, y, z)
    ax.set_title(f'MOT Capture: Time Index {ti}')
    return scat,

ani = FuncAnimation(fig, update, frames=num_frames, interval=50, blit=False)


writer = PillowWriter(fps=20)
ani.save("mot_capture_animation.gif", writer=writer)